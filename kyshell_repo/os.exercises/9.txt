parend
end
23
．在生产者消费者问题中，如果缺少了
signal(full)
或
signal(empty),
对执行结果有何影
响？
答：
如果缺少
signal(full)
，那么表明从第一个生产者进程开始就没有改变信号量
full
值，
即使缓冲池产品已满，但
full
值还是
0
，这样消费者进程执行
wait(full)
时认为缓冲池是空
而取不到产品，消费者进程一直处于等待状态。
如果缺少
signal(empty)
，在生产者进程向
n
个缓冲区投满产品后消费者进程才开始从
中取产品，这时
empty=0
，
full=n
，那么每当消费者进程取走一个产品
empty
值并不改变，
直到缓冲池取空了，
empty
值也是
0
，即使目前缓冲池有
n
个空缓冲区，生产者进程要想
再往缓冲池中投放产品也会因为申请不到空缓冲区被阻塞。
24
．在生产消费者问题中，如果将两个
wait
操作即
wait(full)
和
wait(mutex)
互换位置，
或者将
signal(mutex)
与
signal
（
full
）互换位置，结果如何？
答：将
wait(full)
和
wait(mutex)
互换位置后，可能引起死锁。考虑系统中缓冲区全满时，
若一生产者进程先执行了
wait(mutex)
操作并获得成功，则当再执行
wait(empty)
操作时，
它将因失败而进入阻塞状态，
它期待消费者进程执行
signal(empty)
来唤醒自己，
在此之前，
它不可能执行
signal(mutex)
操作，从而使试图通过执行
wait(mutex)
操作而进入自己的临
界区的其他生产者和所有消费者进程全部进入阻塞状态，这样容易引起系统死锁。
若
signal(mutex)
和
signal(full)
互换位置后只是影响进程对临界资源的释放次序，而
不会引起系统死锁，因此可以互换位置。
25
．
我们在为某一临界资源设置一把锁
W
，
当
W=1
时表示关锁，
当
W=0
时表示锁已打开。
试写出开锁和关锁的原语，并利用他们实现互斥。
答：整型信号量：
lock(W): while W=1 do no-op
W:=1;
unlock(W): W:=0;
记录型信号量：
lock(W): W:=W+1;
if(W>1) then block(W, L)
unlock(W): W:=W-1;
if(W>0) then wakeup(W, L)
例子：
Var W:semaphore:=0
；
begin
repeat
lock(W);